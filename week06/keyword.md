- Debounce & Throttling 🍠
  - Debounce는 무엇일까요?
    Debounce는 사용자의 입력 이벤트가 여러 번 발생할 때 이를 제어하여 성능을 최적화하는 기술입니다. 특히, 사용자가 키보드를 입력할 때 발생하는 `onChange` 이벤트 같은 경우, 입력할 때마다 함수가 호출되면 불필요한 연산이 많아질 수 있습니다. Debounce를 통해 짧은 시간 안에 발생한 여러 이벤트를 묶어서 마지막 이벤트만 처리하도록 함으로써, API 호출 횟수를 줄이거나 불필요한 연산을 방지할 수 있습니다.
  - Debounce는 주로 어디에 사용하나요?
    특정 이벤트가 짧은 시간 내에 빈번하게 발생할 때 이를 최적화하고 불필요한 연산을 줄이기 위해 다양한 상황에서 활용됩니다. (예 - 검색 자동완성 기능)
  - Throttling은 무엇일까요?
    Throttling은 주기적인 간격으로 이벤트를 제한하는 기법입니다. 특정 이벤트가 자주 발생하더라도, 지정된 시간 간격 내에 한 번만 함수를 호출하게 합니다. Throttling은 Debounce와 달리 이벤트가 발생 중일 때도 계속 간격을 두고 함수를 실행하는 특징이 있습니다.
  - Throttling은 주로 어디에 사용하나요?
    성능을 최적화해야 하는 빈번한 이벤트 처리에서 주로 사용됩니다. (예 - 스크롤 이벤트)
  - Debounce와 Throttling의 차이점은 무엇일까요?
    - **Debounce**
      - 지정된 시간 동안 이벤트가 발생하지 않으면 마지막 이벤트만 처리합니다.
      - 이벤트가 빈번히 발생할 때, 마지막 이벤트 이후에만 한 번 실행됩니다.
      - 사용 사례: **검색 입력**에서 마지막 타이핑 이후에 API 요청을 보내거나 **폼 입력 검증** 등에서 효과적입니다.
    - **Throttling**
      - 이벤트가 지속적으로 발생하더라도 지정된 시간 간격마다 한 번씩 함수를 실행합니다.
      - 일정한 간격을 유지하며 이벤트를 실행하기 때문에 빈번한 이벤트 발생 시 성능을 유지하는 데 유리합니다.
      - 사용 사례: **스크롤** 이벤트와 **리사이즈** 이벤트, **무한 스크롤** 등 연속적인 업데이트가 필요한 상황에서 사용됩니다.
  - 어떤 기능을 구현할 때 Debounce를 적용하고, Throttling을 적용하는 것이 좋을까요?
    **Debounce**는 이벤트가 발생한 후 **마지막 동작**을 기준으로 실행되어야 하는 경우에 적합합니다. **Throttling**은 이벤트가 발생하는 동안 주기적으로 **계속 실행**되어야 하는 경우에 적합합니다.
- 쿠키 🍠
  - 쿠키란 무엇이고, 어떤 특징을 가지고 있을까요?
    **쿠키**는 웹 브라우저에 저장되는 작은 데이터 조각으로, 웹사이트가 사용자에 대한 정보를 클라이언트에 저장하고 필요할 때 다시 사용할 수 있도록 합니다. 주로 사용자의 로그인 정보, 설정, 방문 기록 등을 기억해 사용자 경험을 개선하는 데 활용됩니다.
  - 쿠키를 어떻게 사용할 수 있을까요?
    쿠키는 클라이언트와 서버에서 모두 설정하고 사용할 수 있습니다. 자바스크립트나 서버 측 스크립트로 쿠키를 생성, 읽기, 삭제할 수 있습니다. 쿠키의 만료일과 접근 제한을 설정합니다.
- 토큰 🍠
  - 토큰이 왜 필요할까요?
    토큰은 인증 및 권한 부여를 관리하고, 민감한 데이터를 보호하기 위해 사용됩니다. 사용자가 로그인하면 토큰이 발급되며, 서버는 이후의 요청에서 이 토큰을 통해 사용자를 식별합니다. 이를 통해 비밀번호 같은 정보를 매번 전송할 필요가 없어지고, 비동기 방식의 API 호출에서도 보안을 유지할 수 있습니다. 특히, 토큰은 **무상태성**을 지니므로 서버의 세션 관리를 줄여 확장성과 보안을 높이는 데 유리합니다.
  - CORS 에러가 무엇이고, 이 에러를 어떻게 해결할 수 있을까요?
    **CORS (Cross-Origin Resource Sharing)** 에러는 클라이언트가 다른 도메인의 리소스를 요청할 때 발생하는 보안 정책으로, 특정 출처에서만 리소스를 요청하도록 제한합니다. 예를 들어, `example.com`에서 `api.otherdomain.com`에 요청을 보내는 경우, 서버가 해당 출처를 허용하지 않으면 CORS 에러가 발생합니다.
    해결 방법 - 서버에서 CORS 허용 설정, 프록시 서버 사용, 브라우저의 CORS 규칙 우회
  - JWT 토큰 기반 인증 방법이란 무엇일까요?
    **JWT (JSON Web Token)** 기반 인증은 사용자가 로그인할 때 서버가 고유의 JWT 토큰을 발급하고, 이후 요청에서 해당 토큰을 통해 인증을 처리하는 방식입니다. JWT는 클라이언트에서 저장되며, 서버는 이 토큰을 통해 사용자를 식별합니다. 토큰은 **헤더(Header)**, **페이로드(Payload)**, **서명(Signature)**으로 구성되며, Base64로 인코딩되어 사용됩니다.
  - JWT 기반 로그인 동작 과정에 대해 알아보세요.
    1. **로그인 요청**: 사용자가 로그인 정보를 서버에 전송합니다.
    2. **토큰 발급**: 서버는 사용자가 유효한 자격을 갖췄다고 확인되면 JWT를 생성하여 클라이언트에 전달합니다.
    3. **클라이언트 저장**: 클라이언트는 받은 JWT를 로컬 스토리지 또는 쿠키에 저장합니다.
    4. **인증 요청**: 클라이언트는 이후의 요청에 JWT를 포함하여 서버에 전송하고, 서버는 토큰을 검증합니다.
    5. **인증 확인 및 데이터 반환**: 토큰이 유효하면 서버는 요청에 대해 응답하고, 토큰이 만료되었거나 유효하지 않으면 오류를 반환합니다.
  - AccessToken / RefreshToken의 차이에 대해 설명해주세요.
    - **Access Token**: 단기 인증에 사용되며, 보안을 위해 짧은 유효 기간을 가집니다.
    - **Refresh Token**: Access Token 갱신에 사용되며, 보안을 강화하고 사용자 경험을 개선합니다.
- 웹 스토리지 🍠

  - 웹 스토리지의 메소드와 프로퍼티는 어떤게 있을까요?
    **메소드**
    - `setItem(key, value)`: 키-값 쌍을 저장합니다.
    - `getItem(key)`: 키에 해당하는 값을 반환합니다.
    - `removeItem(key)`: 특정 키의 데이터를 삭제합니다.
    - `clear()`: 모든 데이터를 삭제합니다.
    - `key(index)`: 지정된 인덱스에 해당하는 키를 반환합니다.
      **프로퍼티**
    - `length`: 저장된 데이터의 총 개수를 반환합니다.
  - 세션 스토리지에 대해 정리해 주세요!
    **세션 스토리지**는 브라우저 세션 동안만 유지되는 데이터 저장소로, 페이지를 새로고침해도 데이터가 유지되지만, 브라우저 또는 탭을 닫으면 데이터가 삭제됩니다.
  - 로컬 스토리지에 대해 정리해 주세요!
    **로컬 스토리지**는 사용자가 명시적으로 데이터를 삭제하지 않는 한, 브라우저에 영구적으로 데이터를 저장하는 저장소입니다.
  - 로컬 스토리지에서 JWT 토큰을 저장하고, 사용하고, 삭제하는 메소드에 대해 찾아보세요!

    ```jsx
    // JWT 토큰 저장
    localStorage.setItem("token", jwtToken);

    // JWT 토큰 가져오기
    const token = localStorage.getItem("token");

    // JWT 토큰 삭제
    localStorage.removeItem("token");
    ```

  - 스토리지가 변경되었을 때 처리하는 방법을 조사해 주세요.
    웹 스토리지의 데이터가 변경되면 `storage` 이벤트가 발생합니다.
    `jsx
    window.addEventListener("storage", (event) => {
      console.log("스토리지 변경 감지됨:", event.key, event.newValue);
      // 필요 시 동기화 로직 수행
    });
    `
  - Bearer Token이 무엇인지 찾아보고, 이를 통해 백엔드 서버와 어떠한 방식으로 통신하는지 조사해 보세요!
    **Bearer Token**은 HTTP 헤더에 `Authorization` 필드로 포함되어, 인증된 사용자의 요청임을 서버에 전달하는 방법입니다. 주로 JWT 토큰을 Bearer 방식으로 전송하며, API 호출 시 이 토큰을 사용하여 사용자를 인증합니다.
    서버와의 통신 방식 - 로그인, 토큰 저장, API 요청 시 인증 헤더 포함, 서버 인증 및 응답

- Context-API 🍠
  - 전역 상태 관리는 왜 해야할까요?
    - **데이터 일관성 유지**
    - **복잡한 컴포넌트 간 데이터 전달 단순화**
    - **코드 유지보수 및 재사용성 향상**
  - Context API란 무엇일까요?
    **Context API**는 리액트 내장 기능으로, 전역적으로 사용할 수 있는 상태를 관리하는 도구입니다. 주로 props drilling 문제를 해결하기 위해 사용되며, 전역적으로 상태와 함수를 공유하고 필요한 컴포넌트에서 쉽게 접근할 수 있게 합니다.
